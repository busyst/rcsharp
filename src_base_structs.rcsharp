fn __chkstk() : void{ /*Needed*/}
fn _fltused() : i32{ return 0; /*Needed*/}
namespace process{
    #[DllImport("kernel32.dll")]
    fn ExitProcess(code:i32): void;
    
    #[DllImport("kernel32.dll")]
    fn GetModuleFileNameA(hModule: &i8, lpFilename: &i8, nSize: u32): u32;

    fn get_executable_path() : string::String {
        let string : string::String = string::with_size(260);
        let len : u32 = GetModuleFileNameA(0 as &i8, string.data, string.len as u32);
        string.len = len as i32;
        return string;
    }
    fn get_executable_env_path() : string::String {
        let string : string::String = get_executable_path();
        let index : i32 = string.len as i32 - 1;
        loop {
            if string.data[index] == '\\' || index < 0 {
                break;
            }
            index = index - 1;
        }
        string.len = (index + 1) as i32;
        return string;
    }
    fn throw(exception: &i8) : void{
        let len: i32 = string_utils::c_str_len(exception);
        console::AllocConsole();
        let chars_written: i32;
        let stdout_handle: &i8 = console::GetStdHandle(-11 as i32);
        let e: &i8 = "Exception: ";
        console::WriteConsoleA(stdout_handle, e, string_utils::c_str_len(e), &chars_written, 0 as &i8);
        console::WriteConsoleA(stdout_handle, exception, len, &chars_written, 0 as &i8);
        let nl : i8 = 10;
        console::WriteConsoleA(stdout_handle, &nl, 1, &chars_written, 0 as &i8);
        ExitProcess(-1);
    }
}
namespace mem{
    struct PROCESS_HEAP_ENTRY {
        lpData: &void,
        cbData: u32,
        cbOverhead: u8,
        iRegionIndex: u8,
        wFlags: u16,
        Block_hMem: &void,
        Block_dwReserved0: u32,
        Block_dwReserved1: u32,
        Block_dwReserved2: u32,
    }
    #[DllImport("kernel32.dll")]
    fn GetProcessHeap(): &i32;
    #[DllImport("kernel32.dll")]
    fn HeapAlloc(hHeap: &i32, dwFlags: i32, dwBytes: i64): &void;
    #[DllImport("kernel32.dll")]
    fn HeapFree(hHeap: &i32, dwFlags: i32, lpMem: &i8): i32;
    #[DllImport("kernel32.dll")]
    fn HeapSize(hHeap: &i32,dwFlags : i32, lpMem : &i8) : i64;
    #[DllImport("kernel32.dll")]
    
    fn HeapWalk(hHeap: &i32, lpEntry: &PROCESS_HEAP_ENTRY) : i32;
    #[DllImport("kernel32.dll")]
    fn HeapLock(hHeap: &i32) : i32;
    #[DllImport("kernel32.dll")]
    fn HeapUnlock(hHeap: &i32) : i32;

    fn malloc(size:i64) : &void{return HeapAlloc(GetProcessHeap(), 0, size);}
    fn free(ptr: &i8) : void {HeapFree(GetProcessHeap(), 0, ptr);}
    fn copy(src: &i8, dest:&i8, len: i64) {
        let i: i64 = 0;
        loop{
            if i >= len{
                break;
            }
            dest[i] = src[i];
            i = i + 1;
        }
    }
    fn zero_fill(dest:&i8, len: i64) {
        fill(0, dest, len);
    }
    fn fill(val: i8, dest:&i8, len: i64) {
        let i: i64 = 0;
        loop{
            if i >= len{
                break;
            }
            dest[i] = val;
            i = i + 1;
        }
    }
    fn get_total_allocated_memory_external() : i64 {
        let hHeap: &i32 = GetProcessHeap();
        let total_size: i64 = 0;

        let entry: PROCESS_HEAP_ENTRY;
        entry.lpData = 0 as &void; 

        if HeapLock(hHeap) == 0 {
            process::throw("Failed to lock heap for walking.");
        }

        loop {
            if HeapWalk(hHeap, &entry) == 0 {
                break;
            }
            if (entry.wFlags & 0x00000004) != 0 {
                total_size = total_size + (entry.cbData as i64);
            }
        }
        HeapUnlock(hHeap);

        return total_size;
    }
}
namespace list{
    // Linked list
    struct List{
        head: &ListNode,
        foot: &ListNode,
        length: u32,
    }
    // Linked list node
    struct ListNode{
        data: i32,
        next_node: &ListNode,
    }
    fn new(list: &List){
        list.head = 0 as &ListNode;
        list.foot = 0 as &ListNode;
        list.length = 0 as u32;
    }
    fn new_node(list: &ListNode){
        list.next_node = 0 as &ListNode;
        list.data = 0 as i32;
    }
    fn extend(list: &List, data: i32){
        let node_to_add: &ListNode = mem::malloc(sizeof(ListNode)) as &ListNode;
        node_to_add.next_node = 0 as &ListNode;
        node_to_add.data = data;

        if list.head == 0 as &ListNode {
            list.head = node_to_add;
            list.foot = node_to_add;
        } else {
            list.foot.next_node = node_to_add;
            list.foot = node_to_add;
        }
        list.length = list.length + 1 as u32;
    }
    fn walk(list: &List) : u32{
        let l : u32 = 0 as u32;
        let ptr : &ListNode = list.head;
        loop {
            if (ptr == 0 as &ListNode){
                break;
            }
            l = l + 1 as u32;
            ptr = ptr.next_node;
        }
        return l;
    }
    fn free(list: &List) {
        let current: &ListNode = list.head;
        loop {
            if (current == 0 as &ListNode) {
                break;
            }
            let next: &ListNode = current.next_node;
            mem::free(current as &i8); 
            current = next; 
        }
        list.head = 0 as &ListNode;
        list.foot = 0 as &ListNode;
        list.length = 0;
    }
}
namespace vector{
    // Dynamicly expanding array
    struct Vec{
        array: &i8,
        length: u32,
        capacity: u32,
    }
    #[ExtentionOf(Vec)]
    fn new(vec: &Vec){
        vec.array = 0 as &i8;
        vec.length = 0;
        vec.capacity = 0;
    }
    #[ExtentionOf(Vec)]
    fn push(vec: &Vec, data: i8){
        if vec.length >= vec.capacity {
            let new_capacity : u32 = 4;
            if vec.capacity != 0 as u32{
                new_capacity = vec.capacity * 2 as u32;
            }
            
            let new_array: &i8 = mem::malloc(sizeof(i8) * new_capacity as i64) as &i8;

            if vec.array != 0 as &i8 {
                let i : u32 = 0;
                loop{
                    if i >= vec.length {
                        break;
                    }
                    new_array[i] = vec.array[i];
                    i = i + 1 as u32;
                }
                mem::free(vec.array as &i8);
            }
            vec.array = new_array;
            vec.capacity = new_capacity;
        }
        vec.array[vec.length] = data;
        vec.length = vec.length + 1 as u32;
    }
    #[ExtentionOf(Vec)]
    fn push_bulk(vec: &Vec, data: &i8, data_len: i32){
        let index : i32 = 0;
        loop{
            if index >= data_len{
                break;
            }
            push(vec,data[index]);
            index = index + 1;
        }
    }
    #[ExtentionOf(Vec)]
    fn free(vec: &Vec) {
        if vec.array != 0 as &i8 {
            mem::free(vec.array as &i8);
        }
        vec.array = 0 as &i8;
        vec.length = 0;
        vec.capacity = 0;
    }
}
namespace console{
    #[DllImport("kernel32.dll")]
    fn AllocConsole(): i32;

    #[DllImport("kernel32.dll")]
    fn GetStdHandle(nStdHandle: i32): &i8;
    
    #[DllImport("kernel32.dll")]
    fn FreeConsole(): i32;

    #[DllImport("kernel32.dll")]
    fn WriteConsoleA(
        hConsoleOutput: &i8,
        lpBuffer: &i8,
        nNumberOfCharsToWrite: i32,
        lpNumberOfCharsWritten: &i32,
        lpReserved: &i8
    ): i32;

    fn get_stdout() : &i8 {
        let stdout_handle: &i8 = GetStdHandle(-11 as i32);
        if (stdout_handle == -1 as &i8) {
            process::throw("stdout handle was invalid");
        }
        return stdout_handle;
    }
    fn write(buffer: &i8, len: i32){
        let chars_written: i32;
        WriteConsoleA(get_stdout(), buffer, len, &chars_written, 0 as &i8);
        if len != chars_written{
            process::ExitProcess(-2);
        }
    }
    fn write_string(str: &string::String){
        let chars_written: i32;
        WriteConsoleA(get_stdout(), str.data, str.len, &chars_written, 0 as &i8);
        if str.len != chars_written{
            process::ExitProcess(-2);
        }
    }
    fn writeln(buffer: &i8, len: i32){
        if len == 0{
            return;
        }
        let chars_written: i32;
        WriteConsoleA(get_stdout(), buffer, len, &chars_written, 0 as &i8);
        if len != chars_written{
            process::ExitProcess(-2);
        }
        let nl : i8 = 10;
        WriteConsoleA(get_stdout(), &nl, 1, &chars_written, 0 as &i8);
    }
    fn print_char(n: i8) {
        let b : i8 = n;
        write(&b, 1);
    }
    fn println_i64(n: i64) {
        if n >= 0{
            println_u64(n as u64);
        }else{
            print_char('-');
            println_u64(-n as u64);
        }
    }
    fn println_u64(n: u64) {
        let buffer: vector::Vec;
        vector::new(&buffer);
        if (n == 0) {
            vector::push(&buffer, 48 as i8);
            vector::push(&buffer, 10);
            write(buffer.array, buffer.length as i32);
            vector::free(&buffer);
            return;
        }

        let mut_n: u64 = n;

        loop {
            if (mut_n == 0) {
                break;
            }
            let digit_char: i8 = (mut_n % 10) as i8 + (48 as i8);
            vector::push(&buffer, digit_char);
            mut_n = mut_n / 10;
        }

        let i: u32 = 0;
        let j: u32 = buffer.length - 1;
        loop {
            if (i >= j) {
                break;
            }
            let temp: i8 = buffer.array[i];
            buffer.array[i] = buffer.array[j];
            buffer.array[j] = temp;

            i = i + 1;
            j = j - 1;
        }

        vector::push(&buffer, 10); 

        write(buffer.array, buffer.length as i32);
        vector::free(&buffer);
    }
}
namespace string{
    // Always malloc'd, always must be freed
    struct String{
        data: &i8,
        len: i32,
    }
    // USE ONLY WITH NULL TERMINATED STRINGS (from_c_string("...");)
    fn from_c_string(c_string: &i8) : String{
        let x: String;
        x.len = string_utils::c_str_len(c_string) as i32;
        x.data = mem::malloc(sizeof(i8) * x.len as i64) as &i8;
        mem::copy(c_string, x.data, x.len as i64);
        return x;
    }
    fn empty() : String{
        let x: String;
        x.data = 0 as &i8;
        x.len = 0;
        return x;
    }
    fn with_size(size: i32) : String{
        let x: String;
        x.len = size;
        x.data = mem::malloc(sizeof(i8) * size as i64) as &i8;
        return x;
    }

    fn concat_with_c_string(src_string: &String, c_string: &i8) : String{
        let c_string_len : i32 = string_utils::c_str_len(c_string);
        let combined : &i8 = mem::malloc(sizeof(i8) * (c_string_len + src_string.len) as i64)  as &i8;
        mem::copy(src_string.data, combined, src_string.len as i64);
        mem::copy(c_string, (combined + src_string.len as i64), c_string_len as i64);
        let str: String;
        str.data = combined;
        str.len = c_string_len + src_string.len;
        return str;
    }
    fn equal(first: &String, second: &String) : bool{
        if first.len != second.len{
            return 0 as bool;
        }
        let iter: i32 = first.len - 1;
        loop{
            if iter < 0 {
                break;
            }
            if  first.data[iter] != second.data[iter] {
                return 0 as bool;
            }
            iter = iter - 1;
        }
        return 1 as bool;
    }

    fn free(str: &String){
        mem::free(str.data);
        str.len = 0;
    }
    // Use data only inside function where it was called, because stack will be "freed" upon leaving function and data will be corrupted
    inline fn as_c_string_stalloc(string: &String, stallocd_buffer: &i8){
        mem::copy(string.data, stallocd_buffer, string.len as i64);
        stallocd_buffer[string.len] = 0;
    }
}
namespace string_utils{
    fn insert(src1: &i8, src2: &i8, index: i32) : &i8{
        let len1 : i32 = c_str_len(src1);
        let len2 : i32 = c_str_len(src2);
        let output : &i8 = mem::malloc((len1 + len2 + 1) as i64) as &i8;
        mem::copy(src1, output, index as i64);
        mem::copy(src2, (output + index), len2 as i64);
        mem::copy((src1 + index), (output + index + len2), (len1 - index) as i64);
        output[len1 + len2] = 0;
        return output;
    }
    fn c_str_len(str: &i8) : i32{
        let len : i32 = 0;
        loop{
            if str[len] == 0{
                break;
            }
            len = len + 1;
        }
        return len;
    }
    fn is_ascii_num(char: i8) : bool{
        return char >= '0' && char <= '9';
    }
    fn is_ascii_char(char: i8) : bool{
        return (char >= 'A' && char <= 'Z') || (char >= 'a' && char <= 'z');
    }
    fn is_ascii_hex(char: i8) : bool{
        return (char >= '0' && char <= '9') || (char >= 'A' && char <= 'F') || (char >= 'a' && char <= 'f');
    }
}

namespace fs{
    #[DllImport("kernel32.dll")]
    fn CreateFileA(
        lpFileName: &i8,
        dwDesiredAccess: u32,
        dwShareMode: u32,
        lpSecurityAttributes: &i8,
        dwCreationDisposition: u32,
        dwFlagsAndAttributes: u32,
        hTemplateFile: &i8
    ) : &i8; // Returns a HANDLE

    #[DllImport("kernel32.dll")]
    fn WriteFile(
        hFile: &i8,
        lpBuffer: &i8,
        nNumberOfBytesToWrite: u32,
        lpNumberOfBytesWritten: &u32,
        lpOverlapped: &i8
    ) : i32; // Returns a BOOL

    #[DllImport("kernel32.dll")]
    fn ReadFile(
        hFile: &i8,
        lpBuffer: &i8,
        nNumberOfBytesToRead: u32,
        lpNumberOfBytesRead: &u32,
        lpOverlapped: &i8
    ) : i32; // Returns a BOOL
    
    #[DllImport("kernel32.dll")]
    fn GetFileSizeEx(hFile: &i8, lpFileSize: &i64): i32; // Returns BOOL

    #[DllImport("kernel32.dll")]
    fn CloseHandle(hObject: &i8) : i32; // Returns a BOOL

    #[DllImport("kernel32.dll")]
    fn DeleteFileA(lpFileName: &i8) : i32; // Returns a BOOL

    fn write_to_file(path: &i8, content: &i8, content_len: u32) : i32 {
        let CREATE_ALWAYS: u32 = 2;
        let GENERIC_WRITE: u32 = 0x40000000;
        let FILE_ATTRIBUTE_NORMAL: u32 = 0x80;
        let hFile: &i8 = CreateFileA(path, GENERIC_WRITE, 0, 0 as &i8, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0 as &i8);
        let INVALID_HANDLE_VALUE: &i8 = -1 as &i8;
        if hFile == INVALID_HANDLE_VALUE {
            return 0;
        }

        let bytes_written: u32 = 0;
        let success: i32 = WriteFile(hFile, content, content_len, &bytes_written, 0 as &i8);

        CloseHandle(hFile);

        if success == 0 {
            return 0;
        }
        if bytes_written != content_len {
            return 0;
        }

        return 1;
    }
    fn read_full_file_as_string(path: &i8) : string::String {
        let GENERIC_READ: u32 = 0x80000000;
        let FILE_ATTRIBUTE_NORMAL: u32 = 0x80;
        let OPEN_EXISTING: u32 = 3; 
        let hFile: &i8 = CreateFileA(path, GENERIC_READ, 0, 0 as &i8, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0 as &i8);
        let INVALID_HANDLE_VALUE: &i8 = -1 as &i8;

        if hFile == INVALID_HANDLE_VALUE {
            process::throw(string_utils::insert("File  was not found", path, 5));
        }


        let file_size: i64 = 0;
        if GetFileSizeEx(hFile, &file_size) == 0 {
            CloseHandle(hFile);
            return string::empty();
        }

        let buffer: string::String = string::with_size(file_size as i32 + 1);
        

        let bytes_read: u32 = 0;
        let success: i32 = ReadFile(hFile, buffer.data, file_size as u32, &bytes_read, 0 as &i8);
        
        CloseHandle(hFile);

        if success == 0 || (bytes_read as i64) != file_size {
            string::free(&buffer);
            process::throw("File read failed");
        }
        buffer.len = file_size as i32;
        
        return buffer;
    }
    fn create_file(path: &i8) : i32 {
        let CREATE_NEW: u32 = 1;
        let GENERIC_WRITE: u32 = 0x40000000;
        let FILE_ATTRIBUTE_NORMAL: u32 = 0x80;
        
        let hFile: &i8 = CreateFileA(
            path,
            GENERIC_WRITE,
            0, // dwShareMode: No sharing
            0 as &i8, // lpSecurityAttributes: Default security
            CREATE_NEW,
            FILE_ATTRIBUTE_NORMAL,
            0 as &i8 // hTemplateFile: No template
        );

        let INVALID_HANDLE_VALUE: &i8 = -1 as &i8;
        if hFile == INVALID_HANDLE_VALUE {
            return 0;
        }
        CloseHandle(hFile);

        return 1;
    }
    fn delete_file(path: &i8) : i32 {
        return DeleteFileA(path);
    }
}

namespace tests{
    fn run(){
        let pre_test_mem: i64 = mem::get_total_allocated_memory_external();
        mem_test();
        string_utils_test();
        string_test();
        vector_test();
        list_test();
        process_test();
        console_test();
        fs_test();

        funny();
        let post_test_mem: i64 = mem::get_total_allocated_memory_external();
        let delta: i64 = post_test_mem - pre_test_mem;
        console::write("test malloc delta: ", 19);
        console::println_i64(delta);
    }
    fn mem_test(){
        console::write("mem_test: ", 10);
        
        let size: i64 = 16;
        let buffer1: &i8 = mem::malloc(size) as &i8;
        if buffer1 == 0 as &i8 { process::throw("mem_test: malloc failed"); }
        
        // Test fill
        mem::fill('X', buffer1, size);
        let i: i64 = 0;
        loop {
            if i >= size { break; }
            if buffer1[i] != 'X' { process::throw("mem_test: fill verification failed"); }
            i = i + 1;
        }
        // Test zero_fill
        mem::zero_fill(buffer1, size); // First argument is ignored
        i = 0;
        loop {
            if i >= size { break; }
            if buffer1[i] != 0 { process::throw("mem_test: zero_fill verification failed"); }
            i = i + 1;
        }
        
        // Test copy
        let buffer2: &i8 = mem::malloc(size) as &i8;
        if buffer2 == 0 as &i8 { process::throw("mem_test: malloc for copy failed"); }
        mem::fill('Y', buffer2, size);
        mem::copy(buffer2, buffer1, size);
        i = 0;
        loop {
            if i >= size { break; }
            if buffer1[i] != 'Y' { process::throw("mem_test: copy verification failed"); }
            i = i + 1;
        }

        mem::free(buffer1);
        mem::free(buffer2);
        
        console::writeln("OK", 2);
    }
    fn string_utils_test() {
        console::write("string_utils_test: ", 19);

        if string_utils::c_str_len("test") != 4 { process::throw("string_utils_test: c_str_len failed"); }
        if string_utils::c_str_len("") != 0 { process::throw("string_utils_test: c_str_len empty failed"); }

        if !string_utils::is_ascii_num('7') || string_utils::is_ascii_num('b') { process::throw("string_utils_test: is_ascii_num failed"); }
        if !string_utils::is_ascii_char('a') || string_utils::is_ascii_char('9') { process::throw("string_utils_test: is_ascii_char failed"); }
        if !string_utils::is_ascii_hex('F') || string_utils::is_ascii_hex('G') { process::throw("string_utils_test: is_ascii_hex failed"); }

        let inserted: &i8 = string_utils::insert("ac", "b", 1);
        let expected: &i8 = "abc";
        let i: i32 = 0;
        loop {
            if inserted[i] == 0 && expected[i] == 0 { break; }
            if inserted[i] != expected[i] { process::throw("string_utils_test: insert failed"); }
            i = i + 1;
        }
        mem::free(inserted);

        console::writeln("OK", 2);
    }
    
    fn string_test(){
        console::write("string_test: ", 13);

        let s1: string::String = string::from_c_string("hello");
        let s2: string::String = string::from_c_string("hello");
        let s3: string::String = string::from_c_string("world");

        if s1.len != 5 { process::throw("string_test: from_c_string length failed"); }
        if !string::equal(&s1, &s2) { process::throw("string_test: equal positive case failed"); }
        if string::equal(&s1, &s3) { process::throw("string_test: equal negative case failed"); }

        let s4: string::String = string::concat_with_c_string(&s1, " world");
        let s5: string::String = string::from_c_string("hello world");
        
        if s4.len != 11 { process::throw("string_test: concat length failed"); }
        if !string::equal(&s4, &s5) { process::throw("string_test: concat content failed"); }

        string::free(&s1);
        string::free(&s2);
        string::free(&s3);
        string::free(&s4);
        string::free(&s5);

        console::writeln("OK", 2);
    }
    
    fn vector_test() {
        console::write("vector_test: ", 13);
        
        let v: vector::Vec;
        vector::new(&v);
        
        if v.length != 0 || v.capacity != 0 { process::throw("vector_test: new failed"); }

        vector::push(&v, 10); vector::push(&v, 20); vector::push(&v, 30); vector::push(&v, 40);

        if v.length != 4 || v.capacity != 4 { process::throw("vector_test: initial push failed"); }
        if v.array[0] != 10 || v.array[3] != 40 { process::throw("vector_test: initial content failed"); }
        
        vector::push(&v, 50); // Trigger reallocation

        if v.length != 5 || v.capacity != 8 { process::throw("vector_test: realloc failed"); }
        if v.array[4] != 50 || v.array[0] != 10 { process::throw("vector_test: realloc content failed"); }
        
        let data_to_push: &i8 = "AB";
        vector::push_bulk(&v, data_to_push, 2);
        if v.length != 7 { process::throw("vector_test: push_bulk length failed"); }
        if v.array[5] != 'A' || v.array[6] != 'B' { process::throw("vector_test: push_bulk content failed"); }
        
        vector::free(&v);
        if v.length != 0 || v.capacity != 0 || v.array != 0 as &i8 { process::throw("vector_test: free failed"); }
        
        console::writeln("OK", 2);
    }
    fn list_test() {
        console::write("list_test: ", 11);

        let l: list::List;
        list::new(&l);
        if l.length != 0 || l.head != 0 as &list::ListNode { process::throw("list_test: new failed"); }

        list::extend(&l, 100);
        list::extend(&l, 200);
        list::extend(&l, 300);

        if l.length != 3 { process::throw("list_test: length incorrect after extend"); }
        if list::walk(&l) != 3 { process::throw("list_test: walk length incorrect"); }

        let current: &list::ListNode = l.head;
        if current.data != 100 { process::throw("list_test: data mismatch for node 1"); }
        current = current.next_node;
        if current.data != 200 { process::throw("list_test: data mismatch for node 2"); }
        current = current.next_node;
        if current.data != 300 { process::throw("list_test: data mismatch for node 3"); }
        if current != l.foot { process::throw("list_test: foot pointer mismatch"); }
        
        list::free(&l);
        if l.length != 0 || l.head != 0 as &list::ListNode { process::throw("list_test: free failed"); }

        console::writeln("OK", 2);
    }
    fn process_test() {
        console::write("process_test: ", 14);
        
        let full_path: string::String = process::get_executable_path();
        let env_path: string::String = process::get_executable_env_path();
        
        if full_path.len <= 0 { process::throw("process_test: get_executable_path returned empty"); }
        if env_path.len <= 0 { process::throw("process_test: get_executable_env_path returned empty"); }
        if env_path.len >= full_path.len { process::throw("process_test: env path is not shorter than full path"); }
        if env_path.data[env_path.len - 1] != '\\' { process::throw("process_test: env path does not end with a backslash"); }
        
        console::write("Executable Path: ", 17);
        console::writeln(full_path.data, full_path.len);
        console::write("Environment Path: ", 18);
        console::writeln(env_path.data, env_path.len);

        string::free(&full_path);
        string::free(&env_path);

        console::writeln("OK", 2);
    }
    
    fn console_test() {
        console::writeln("\nconsole_test:", 14);
        console::writeln("--- VISUAL TEST START ---", 25);

        console::write("Printing i64(12345): ", 21);
        console::println_i64(12345);

        console::write("Printing i64(-67890): ", 22);
        console::println_i64(-67890);
        
        console::write("Printing i64(0): ", 17);
        console::println_i64(0);

        console::write("Printing u64(9876543210): ", 26);
        console::println_u64(9876543210);

        console::writeln("--- VISUAL TEST END ---", 23);
        console::writeln("OK", 2);
    }
    fn fs_test(){
        console::write("fs_test: ", 9);
        let data : string::String = string::from_c_string("The quick brown fox jumps over crazy lost dog.");
        let env_path : string::String = process::get_executable_env_path();
        let new_file_path: string::String = string::concat_with_c_string(&env_path, "test.txt");

        let c_string : &i8 = stalloc(sizeof(i8) * (new_file_path.len + 1) as i64);
        string::as_c_string_stalloc(&new_file_path, c_string);

        fs::create_file(c_string);
        fs::delete_file(c_string);

        fs::create_file(c_string);
        fs::write_to_file(c_string, data.data, data.len as u32);
        
        let read: string::String = fs::read_full_file_as_string(c_string);
        if !string::equal(&data, &read){
            process::throw("Filesystem test failed, data mismatch");
        }

        fs::delete_file(c_string);
        string::free(&read);
        string::free(&new_file_path);
        string::free(&env_path);
        string::free(&data);
        console::writeln("OK", 2);
    }
    fn consume_while(file: &string::String, iterator: &i32, condition: &fn(i8) : bool) {
        loop {
            if *iterator >= file.len {
                break;
            }
            let char : i8 = file.data[*iterator];
            if (*condition)(char) {
                *iterator = *iterator + 1;
            } else {
                break;
            }
        }
    }
    fn not_new_line(c:i8) : bool { return c != '\n'; }
    fn valid_name_token(c:i8) : bool { return string_utils::is_ascii_char(c) || string_utils::is_ascii_num(c) || c == '_'; }
    fn is_valid_number_token(c:i8) : bool { return string_utils::is_ascii_num(c) || string_utils::is_ascii_hex(c) || c == '_'; }
    // No.
    fn funny(){
        let path: &i8 = "D:\\Projects\\rcsharp\\src_base_structs.rcsharp";
        let file: string::String = fs::read_full_file_as_string(path);
        let tokens: vector::Vec;
        vector::new(&tokens); 
        let iterator: i32 = 0;
        let char: i8;
        let next_char: i8;
        let index: i32;
        let temp_string: string::String;
        let line: i32 = 0;
        let line_index: i32 = 0;
        loop{
            if iterator >= file.len {
                break;
            }
            char = file.data[iterator];
            if char == '\n'{
                line = line + 1;
                line_index = iterator;
                iterator = iterator + 1;
                continue;
            }
            if (char == ' ' || char == '\t' || char == '\r') && 1 as bool{
                iterator = iterator + 1;
                continue;
            }

            if (iterator + 1) < file.len{
                next_char = file.data[iterator + 1];
            }else{
                next_char = 0;
            }
            
            if char == '/' && next_char == '/'{
                index = iterator;
                consume_while(&file, &iterator, &not_new_line);
                continue;
            }
            if string_utils::is_ascii_num(char){
                index = iterator;
                if next_char == 'x' || next_char == 'b'{
                    iterator = iterator + 2;
                }
                consume_while(&file, &iterator, &is_valid_number_token);
                // Num string
                temp_string = string::with_size(iterator - index);
                mem::copy(file.data + index, temp_string.data, temp_string.len as i64);
                //console::write_string(&temp_string);
                //console::print_char('\n');
                string::free(&temp_string);
                continue;
            }

            if string_utils::is_ascii_char(char) || char == '_'{
                index = iterator;
                consume_while(&file, &iterator, &valid_name_token);
                // name token string
                temp_string = string::with_size(iterator - index);
                mem::copy(file.data + index, temp_string.data, temp_string.len as i64);
                //console::write_string(&temp_string);
                //console::print_char('\n');
                string::free(&temp_string);
                continue;
            }

            if char == '"'{
                index = iterator;
                loop{
                    iterator = iterator + 1;
                    if iterator >= file.len {
                        break;
                    }
                    char = file.data[iterator];
                    if char != '"'{
                        continue;
                    }
                    iterator = iterator + 1;
                    break;
                }
                // string token
                temp_string = string::with_size(iterator - index);
                mem::copy(file.data + index, temp_string.data, temp_string.len as i64);
                string::free(&temp_string);
                continue;
            }
            if char == '\''{
                iterator = iterator + 1;
                continue;
            }
            if char == '('{
                iterator = iterator + 1;
                continue;
            }
            if char == ')'{
                iterator = iterator + 1;
                continue;
            }
            if char == '{'{
                iterator = iterator + 1;
                continue;
            }
            if char == '}'{
                iterator = iterator + 1;
                continue;
            }
            if char == '['{
                iterator = iterator + 1;
                continue;
            }
            if char == ']'{
                iterator = iterator + 1;
                continue;
            }
            if char == '='{
                if next_char == '='{
                    iterator = iterator + 2;
                    continue;
                }
                iterator = iterator + 1;
                continue;
            }
            if char == ':'{
                if next_char == ':'{
                    iterator = iterator + 2;
                    continue;
                }
                iterator = iterator + 1;
                continue;
            }
            if char == '|'{
                if next_char == '|'{
                    iterator = iterator + 2;
                    continue;
                }
                iterator = iterator + 1;
                continue;
            }
            if char == '&'{
                if next_char == '&'{
                    iterator = iterator + 2;
                    continue;
                }
                iterator = iterator + 1;
                continue;
            }
            if char == '>'{
                if next_char == '='{
                    iterator = iterator + 2;
                    continue;
                }
                iterator = iterator + 1;
                continue;
            }
            if char == '<'{
                if next_char == '='{
                    iterator = iterator + 2;
                    continue;
                }
                iterator = iterator + 1;
                continue;
            }
            if char == '#'{
                iterator = iterator + 1;
                continue;
            }
            if char == ';'{
                iterator = iterator + 1;
                continue;
            }
            if char == '.'{
                iterator = iterator + 1;
                continue;
            }
            if char == ','{
                iterator = iterator + 1;
                continue;
            }
            if char == '+'{
                iterator = iterator + 1;
                continue;
            }
            if char == '-'{
                iterator = iterator + 1;
                continue;
            }
            if char == '*'{
                iterator = iterator + 1;
                continue;
            }
            if char == '/'{
                iterator = iterator + 1;
                continue;
            }
            if char == '%'{
                iterator = iterator + 1;
                continue;
            }
            if char == '!'{
                iterator = iterator + 1;
                continue;
            }
            if char == '~'{
                iterator = iterator + 1;
                continue;
            }
            if char == '\\'{
                iterator = iterator + 1;
                continue;
            }
            console::print_char(char);
            console::print_char('\n');
            console::println_u64(line as u64);
            console::println_u64((iterator - line_index) as u64);
            iterator = iterator + 1;
        }
        vector::free(&tokens);
        string::free(&file);
    }
}