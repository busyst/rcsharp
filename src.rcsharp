/*
// #[ExtentionOf(...)] it does nothing now, but it can be proto-struct function calling, example:
#[ExtentionOf(List)]
fn new(list: &List){
    list.head = 0 as &ListNode;
    list.foot = 0 as &ListNode;
    list.length = 0 as u32;
}
fn main(){
    let list: List;     // can be pointer, does not matter

    list.new();         // can be confusing and hard to "catch" when called accidently, will pollute member suggestion (SHIFT + SPACE)  
    ---OR/AND---
    List::new(&list);   // too much text to write, but clearly indicates static function
    ---OR/AND---
    list = List::new(); // only when `fn new` returns List; Clearly indicates static function. and makes sense. But produces unnecesary copy, that can be avoided with better compilator. 
    // In this case: How to differentiate between stalloc and malloc? How to call this "constructor" on pointers?
    // let list: &List = malloc(sizeof(List)) as &List; *list = List::new(); // is the solution it current situation.
    list = List.new(); // Looks bad. actualy good only in C# and only in universe where new keyword never had existed
    let list: List(); // Looks cursed, C++ inspiration
}
*/

// with new optimisation arguments MUST be immutable. // This statement is no longer valid, i reverted it
fn println_i32(n: i32){
    let buffer: Vec;
    new_vec(&buffer);
    if (n == 0) {
        push(&buffer, 48 as i8);
        push(&buffer, 10);
        write(buffer.array, buffer.length as i32);
        free_vec(&buffer);
        return;
    }
    let mut_n: i64 = n as i64;
    let is_negative: i32 = 0;
    if (mut_n < 0) {
        is_negative = 1;
        mut_n = -mut_n;
    }
    loop {
        if (mut_n == 0) {
            break;
        }
        let digit_char: i8 = (mut_n % 10) as i8 + (48 as i8);
        push(&buffer, digit_char);
        mut_n = mut_n / 10;
    }
    if (is_negative != 0) {
        push(&buffer, 45 as i8);
    }
    let i: u32 = 0;
    let j: u32 = buffer.length - 1;
    loop {
        if (i >= j) {
            break;
        }
        let temp: i8 = *(buffer.array + i as i64);
        *(buffer.array + i as i64) = *(buffer.array + j as i64);
        *(buffer.array + j as i64) = temp;

        i = i + 1;
        j = j - 1;
    }
    push(&buffer, 10);
    write(buffer.array, buffer.length as i32);
    free_vec(&buffer);
}
fn c_str_len(str: &i8) : i32{
    let len : i32 = 0;
    loop{
        if *(str + len as i64) == 0{
            break; // for me it is better to read
        }
        len = len + 1;
    }
    return len;
}
// x!!!
fn triple_factorial(x: i64) : i64{
    if x < 0{
        return 0;
    }
    if x <= 3{
        return 1;
    }
    return x * triple_factorial(x - 3);

}
fn main(): i32 {
    let x : &i8 = "Pee pee poo poo\n Waterfall \n TORRONTO CENTRAL \n";
    let y : &&i8 = &x;
    let z : &&&i8 = &y;
    println_i32((*x) as i32);
    println_i32((**y) as i32);
    println_i32((***z) as i32);
    let i: i64 = 0;
    loop{
        println_i32(triple_factorial(i) as i32);
        i = i + 1;
        if i >= 15{
            break;
        }
    }
    AllocConsole();
    write(x, c_str_len(x));
    println_i32(*"0" as i32);
    println_i32(-1432);
    println_i32(1342);
    println_i32(777);
    FreeConsole();
    let buffer: Vec;
    new_vec(&buffer);
    push(&buffer, 32);
    free_vec(&buffer);
    let list: List;
    new_list(&list);
    extend(&list, 64);
    free_list(&list);
    return 0;
}