/// General language specs /// SOME NOT YET IMPLEMENTED
// Rust basic syntax. (Less characters to lex through:fn,let. Easier to parse: let val_name : type = expression; fn name(args) type {body})
// C memory access and handholding level. (Pointers everywhere, no refereces through)
// C# (Generic type params fn x<T>(), Properties )
// those specs are incomplete as current state of language is bare C with rust-like syntax.

/// Plans ///
// Compile-Time Type Overlay a.k.a (constant_mask) 
// For constant index access to array(array[number]), at compile time substitutes type
// example // indexing with [] NOT YET IMPLEMENTED
// let x: &&void;
// constant_mask!(x, &i32, &bool);
// OR //
// #[constant_mask(&i32, &bool)]
// let x: &&void;
// x = malloc(sizeof(&void) * 4) as &&void;
// let i : i32 = 0;
//
// x[0] = &i; // OK
// x[0] = 0 as &void; // Compile time error, must cast to &i32
// let val : i32 = *x[0]; // OK
// let val : i32 = *x[*val]; // Compile time error, cant cast void to int
//
// let iterator: i32 = 0; // when it isnt number constant_mask does not work
// x[iterator] = &i; // Compile time error, must cast to &void
// x[iterator] = 0 as &void; // OK
//
// WHY DO I NEED THIS: 
// I needed this functionality once, long time ago. It probably was my C++ game engine project and first type in array was always Transform.
// I ended up (Transform*)ing all over the place. Probably constexpr function to staticly cast pointer would have been better.
// ALSO can be used to create "'growing' structures" and interfaces to exposed arrays without needeng to create structures, because it could be overlayed at Vec array 
// -------------------------------------------------------------------------------------------------------------------------------------------------------------------

// with new optimisation arguments MUST be immutable.
fn println_i32(n: i32){
    let buffer: Vec;
    new_vec(&buffer);
    if (n == 0) {
        push(&buffer, 48 as i8);
        push(&buffer, 10);
        write(buffer.array, buffer.length as i32);
        free_vec(&buffer);
        return;
    }
    let mut_n: i64 = n as i64;
    let is_negative: i32 = 0;
    if (mut_n < 0) {
        is_negative = 1;
        mut_n = -mut_n;
    }
    loop {
        if (mut_n == 0) {
            break;
        }
        let digit_char: i8 = (mut_n % 10) as i8 + (48 as i8);
        push(&buffer, digit_char);
        mut_n = mut_n / 10;
    }
    if (is_negative != 0) {
        push(&buffer, 45 as i8);
    }
    let i: u32 = 0;
    let j: u32 = buffer.length - 1;
    loop {
        if (i >= j) {
            break;
        }
        let temp: i8 = *(buffer.array + i as i64);
        *(buffer.array + i as i64) = *(buffer.array + j as i64);
        *(buffer.array + j as i64) = temp;

        i = i + 1;
        j = j - 1;
    }
    push(&buffer, 10);
    write(buffer.array, buffer.length as i32);
    free_vec(&buffer);
}
fn c_str_len(str: &i8) : i32{
    let len : i32 = 0;
    loop{
        if *(str + len as i64) == 0{
            break;
        }
        len = len + 1;
    }
    return len;
}
// x!!!
fn triple_factorial(x: i64) : i64{
    if x < 0{
        return 0;
    }
    if x <= 3{
        return 1;
    }
    return x * triple_factorial(x - 3);

}
fn main(): i32 {
    let c : &fn(i64):i64 = &triple_factorial;
    let x : &i8 = "Pee pee poo poo\n Waterfall \n TORRONTO CENTRAL \n";
    let y : &&i8 = &x;
    let z : &&&i8 = &y;
    println_i32((*x) as i32);
    println_i32((**y) as i32);
    println_i32((***z) as i32);
    let i: i64 = 0;
    loop{
        i = i + 1;
        if i >= 15{
            break;
        }
    }
    AllocConsole();
    write(x, c_str_len(x));
    println_i32(*"0" as i32);
    println_i32(-1432);
    println_i32(1342);
    println_i32(777);
    FreeConsole();
    
    let vec: Vec;
    new_vec(&vec);
    push(&vec, 32);
    free_vec(&vec);
    
    let list: List;
    new_list(&list);
    extend(&list, 64);
    free_list(&list);

    return 0;
}