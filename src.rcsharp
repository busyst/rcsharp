#include("./src_base_structs.rcsharp")

 fn basic_functions() {
    console::AllocConsole();
    tests::run();
    window::start();
    console::FreeConsole();
}
struct Pair<T, U> { first: T, second: U }
fn ax<T>() : Pair<T, Pair<i8, string::String>>{
    let p: Pair<T, Pair<i8, string::String>>;
    p.first = 43 as T;
    p.second.first = 126 as i8;
    return p;
}
fn ay<T>() : Pair<T, Pair<i8, Pair<T, Pair<i8, Pair<T, Pair<i8, Pair<T, Pair<Pair<T, Pair<i8, string::String>>, string::String>>>>>>>>{
    
}
fn of_fn() : &fn() : &fn() : void{
    return of_fn();
}
namespace test{
    struct QPair<T, U> { first: T, second: U }
    fn geg() : QPair<i64, i64>{
        let temp: QPair<i64, i64>;
        temp.first = 1337;
        temp.second = 1226;
        temp.first = temp.first - temp.second;
        return temp;
    }
}
fn xq() : test::QPair<i64, i64>{
    const y : &fn() : test::QPair<i64, i64> = ptr_of(test::geg);
    return (*y)();
}
static yt : [i32; 43];
fn main(): i32 {
    yt[42] = 9999000;
    const f : f64 = 31415.45675678567895636231454568;
    const tp : &fn() : i32 = ptr_of(main);
    const tx : &fn() : Pair<i32, Pair<i8, string::String>> = ptr_of(ax::<i32>);
    let y : Pair<i32, Pair<i8, string::String>> = (*tx)();
    console::println_i64(y.second.first as i64);
    console::println_f64(f as f64);
    console::println_i64(f as i64);
    console::println_i64(bitcast::<i64>(f));
    console::println_f64(bitcast::<f64>(bitcast::<i64>(f) + 123123123123));
    basic_functions();
    const temp : test::QPair<i64, i64> = xq();
    return (bitcast::<isize>(tx) - bitcast::<isize>(tp)) as i32 + yt[42];
}